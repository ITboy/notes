# 异步IO的本质
现在异步非常流行，那么异步的本质到底是什么呢？

## 计算机CPU和IO设备之间本来就是异步的 ##
现代计算机系统中CPU和IO设备之间设计是异步的，显然当CPU向磁盘或网卡发送一条IO指令后，CPU并不会等待磁盘/网卡告诉他，我已经写/读完了，才会进行接下来的事情。
本质上IO中断就是所有上层异步实现的本质。当CPU向磁盘发送写信号，CPU继续处理后续操作系统分发的指令（不会等待），磁盘则兢兢业业的转动探头写数据，当磁盘写好之后会通过磁盘控制器总线告诉CPU写好了，对CPU而言，他通过磁盘控制器收到了IO中断，他会暂停现在所做的事情，执行中断回调函数，在中断回调函数中将磁盘控制器告诉他的数据拷贝到内核缓冲区，并调用相应的用户空间回调函数处理。

## 同步是怎么实现的 ##
为了方便开发者开发应用，操作系统的系统调用被设计成同步方式，当用户调用系统调用执行写操作时，内核会把当前线程加入等待队列，此时CPU的调度不会再为他分配时间片，内核则不断的将这一大块数据打散，通过多次访问磁盘控制器将数据写入磁盘，当磁盘最后将写入成功通知内核中断处理函数，此时内核相应的回调函数发现用户空间告诉他的数据都已经写完了，就不再向磁盘控制器发送写指令，而是把数据拷贝到用户空间，并将之前的进程加入运行队列，等待CPU调度。
所以，同步只是对于应用进程而言，对设备IO永远无法阻塞CPU。

## 异步IO的系统调用 ##
同步IO虽然方便开发，但是对系统而言，CPU的利用率实在太低，如果要开发并发系统，同步IO就必须配合多线程来增加系统的实时性、并发性，也就是说由操作系统的调度系统来决定CPU和IO之间的切换。这显然有很大的弊端，比如线程切换上下文的开销，而且由于进程调度不是为你的应用量身定做，有很多的局限性，CPU利用率仍然很低。这就需要异步IO。
如果你的应用是使用异步IO，如果你的系统没有别的进程占用CPU资源（理想情况），理论上只要你的程序一直给CPU发送执行指令，CPU的利用率就可以达到100%，没有任何浪费的操作（线程上下文切换），而且IO和CPU的执行完全交由开发者决定。

异步IO虽然高效，但是由于开发不方便，而且对于大多数的业务流程，涉及到多次IO和CPU切换的频率并不多，比如对于word文档应用，当点击保存，只有一次IO把数据写入磁盘。

## IO多路复用 ##
之前我们讨论的都是应用程序需要CPU和IO资源来共同完成业务流程，而没有考虑到应用程序作为IO的处理者。
传统的IO可能是由计算机硬件处理，如硬盘、网卡。但其实网络服务器本身的角色也是IO的处理者。随着互联网的发展，高并发的场景越来越普遍，网络应用程序需要处理更多的IO，而这些处理高并发IO的应用程序按照传统的设计只能使用多线程来处理业务。而多线程由于本身带来的资源占用很高，这样如果能使用单线程+异步模型来取代多线程+同步模型解决这个问题就好了，这就是IO的多路复用。

IO的多路复用就是select/poll/epoll对socket的处理。

作为IO的处理者，应用程序可以处理鼠标事件、键盘事件、串口事件、网络事件等等，但是除了网络事件，别的IO事件无法做到高并发，对于高并发的场合，我们只需要考虑网络事件，在传统的网络开发中，使用`accept`系统调用来等待别的应用连接，使用`send`或`recv`系统调用来发送或接收数据。这种方式的缺点是只能使用同步IO，而且一次只能处理一个fd，而IO的多路复用使得应用程序可以同时监听多个fd的状态，从而对有事件发生的fd进行异步IO的操作，这样就可以把对来自不同发送方的IO事件交由一个线程来处理，这样所有的IO和CPU分配都有这一个线程处理，就可以极大的发挥异步IO的优势。

所以现在对于网络应用，IO的多路复用+异步IO成为最高效的解决方案，多路复用负责处理接收的网络事件，异步IO来访问别的IO资源。

## 硬盘的并发IO ##
对于网络的并发IO，网卡设备处理到底有没有真正的并行我还不了解，但是对于普通的PC而言，上行速率的要求并不高，所以我认为在内核中，使用简单的中断（异步）来做到异步差不多就可以满足需求了。而对于网络应用程序，以及网络应用程序系统上的网卡，他们所面对的不只是操作系统本身，而是庞大的互联网，所以他要考虑的并发就要复杂很多，网络应用使用IO的多路复用来应对，而目前的硬盘的IO作为网络并发的处理者经常成为瓶颈，那么硬盘IO的并发如何应对的呢？

## NIO VS. AIO ##

在NIO中，当发生相应读写事件时，用户线程得到通知，表明数据已就绪，开始同步调用非阻塞读写函数，Java API如下：
```java
java.nio.channels.SocketChannel.read(ByteBuffer dst)
java.nio.channels.SocketChannel.write(ByteBuffer src)
```
在AIO中，当发生相应事件时，用户线程得到通知，表明I/O操作已经由操作系统异步完成，用户线程只需事先向内核申明I/O缓冲区、注册handler并定义回调的completed方法即可，Java API如下：
```
java.nio.channels.AsynchronousSocketChannel.read(ByteBuffer dst, ByteBuffer attachment, CompletionHandler<Integer, ? super ByteBuffer> handler)
java.nio.channels.AsynchronousSocketCh
```

AIO与NIO的区别，在Server端体现为Reactor/Proactor的区别，在NIO中，监控的事件通常为数据的到达；在AIO中，监控的是事件通常为I/O的完成。
> reactor：能收了你跟俺说一声。
> proactor: 你给我收十个字节，收好了跟俺说一声。